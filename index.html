<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<meta name="apple-mobile-web-app-capable" content="yes" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
	<meta name="description" content="">
	<meta name="author" content="Ulises Jeremias Cornejo Fandos">

	<title>TTPS</title>

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/solarized.css" id="theme">
	<!-- Code syntax highlighting -->
	<link rel="stylesheet" href="lib/css/atom-one-dark.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>
</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section>
				<h3>Técnicas y Estrategias para la Resolución de Problemas</h3>
			</section>
			<section>
				<section data-autoslide="1500">
					<h2>Presentación</h2>
				</section>
				<section>
					<p><strong>Alumno</strong></p>
					<p><em>Ulises Jeremias Cornejo Fandos</em></p>
				</section>
				<section>
					<h4>Ejercicio propuesto</h4>
					<a target="_blank" href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1541">
						<p class="fragment grow"><strong>ACM Contest and Blackout</strong></p>
					</a>
				</section>
			</section>
			<section>
				<section>
					<h2>Conceptos necesarios</h2>
				</section>
				<section>
					<h3>Grafo</h3>
					<p>Un grafo \(G\) es un par ordenado \(G = (V, E)\) donde:</p>
					<ul>
						<li class="fragment fade-up">
							\(V\) es un conjunto de vértices <em>ó nodos</em>
						</li>
						<li class="fragment fade-up">
							\(E\) es un conjunto de aristas <em>ó arcos</em> <small class="fragment fade-up">Permiten representar relaciones binarias entre elementos de \(V\).</small>
						</li>
					</ul>
				</section>
				<section>
					<h3>Grafo no dirigido</h3>
					<p>Un <em>grafo no dirigido</em> es un grafo \(G = (V, E)\) donde:</p>
					<p class="fragment fade-up">\[ V \neq \emptyset \]</p>
					<p class="fragment fade-up">\[ E \subseteq \{ x \in P(V) : |x| = 2 \} \] <small class="fragment fade-up">es un conjunto de pares no ordenados de elementos de \(V\)</small></p>
				</section>
				<section>
					<h3>Grafo conexo</h3>
					<p>En teoría de grafos, un grafo \(G\) se dice conexo si, para cualquier par de vértices \( u,v \in G \), existe al menos una trayectoria (una sucesión de vértices adyacentes que no repita vértices) de u a v.</p>
				</section>
				<section>
					<h3>Grafo etiquetado</h3>
					<p>En matemáticas, en la disciplina de teoría de grafos, un grafo etiquetado es la asignación de etiquetas, tradicionalmente representada mediante enteros, a las aristas o vértices, o ambos, de un grafo.</p>
				</section>
				<section>
					<h3>Grafo ponderado</h3>
					<p>Formalmente, dado un grafo \(G\), un vértice etiquetado es una función que hace corresponder vértices de G a un conjunto de etiquetas. Un grafo con tal función definida es llamado grafo de vértices etiquetados. De la misma manera, una arista etiquetada
						es una función de asignación de aristas de G tal conjunto de «etiquetas». En este caso, G es llamado como grafo de aristas etiquetadas. Cuando las etiquetas de las aristas pertenecen a un conjunto ordenado, ésta puede ser llamada como grafo ponderado.</p>
				</section>
			</section>
			<section>
				<section>
					<h2>ACM Contest and Blackout</h2>
				</section>
				<section>
					<p>Con el fin de preparar el "Primer Concurso Escolar de la Asociación Nacional de Maquinaria Informática" (en 20 ??) el alcalde de la ciudad decidió para proporcionar a todas las escuelas una fuente confiable de poder. (El alcalde tiene realmente miedo
						a los apagonesJ). Entonces, para hacer eso, la central eléctrica "Futuro" y una escuela (no importa cuál) deben ser conectado; Además, algunas escuelas también deben estar conectadas.</p>
				</section>
				<section>
					<p>Puede suponer que una escuela tiene una fuente confiable de poder si está conectada directamente con "Futuro", o a cualquier otra escuela que tenga una fuente confiable de poder. Se le da el costo de la conexión entre algunas escuelas. El alcalde
						ha decidido elegir dos planes de conexión más baratos: el costo del la conexión es igual a la suma de las conexiones entre las escuelas. Tu tarea es ayudar al mayor - encuentre el costo de los dos planes de conexión más baratos.</p>
				</section>
			</section>
			<section>
				<section>
					<h2>Input</h2>
				</section>
				<section>
					<p>La entrada comienza con el <span class="fragment highlight-blue">número de casos de prueba, \( T (1
						< T < 15) \)</span> en una línea. Luego, siguen los T casos de prueba. La primera línea de cada caso de prueba contiene dos números, que están separados por un espacio, <span class="fragment highlight-red">\( N (3
						< N < 100) \) el número de escuelas en la ciudad</span>, y <span class="fragment highlight-red">M el número de conexiones posibles entre ellos</span>. Las siguientes líneas M contienen tres números <span class="fragment highlight-green">\(A_i\), \(B_i\), \(C_i\), donde \(C_i\) es el
						costo de la conexión \( (1
						< C_i < 300) \) entre las escuelas \(A_i\) y \(B_i\)</span>. Las escuelas están numeradas con números enteros en el rango de 1 a N.</p>
				</section>
			</section>
			<section>
				<section>
					<h2>Output</h2>
				</section>
				<section>
					<p>Para cada caso de prueba, <span class="fragment highlight-blue">imprima solo una línea de salida</span>. Esta línea debe contener dos números separados por un solo espacio: el costo de dos de los planes de conexión más económicos. Deje S1 ser el
						costo más barato y S2 el próximo costo más barato. Es importante que, <span class="fragment highlight-red">S1 = S2 si y solo si hay dos planes más baratos, de lo contrario S1
						< S2</span>. <span class="fragment highlight-red">Puede suponer que siempre es posible encontrar los costos S1 y S2.</span>
					</p>
				</section>
			</section>
			<section>
				<section>
					<h2>Análisis</h2>
				</section>
				<section>
					<p>Podemos plantear la solución del problema utilizando grafos, pudiendo ser el conjunto de vertices las escuelas y el costo de la conexión entre dos escuelas el peso de las aristas.</p>
				</section>
				<section>
					<p>Dado un grafo \( G = (V, E) \) no dirigido, pesado y conexo, se debe seleccionar el subconjunto de aristas \( Eꞌ \subset E \), de manera que el grafo \(G\) siga estando conectado y el <span class="fragment highlight-red">peso total de las aristas seleccionadas sea mínimo</span>.</p>
				</section>
				<section>
					<p>Luego, el ejercicio se resuelve buscando un <span class="fragment highlight-red">Arbol de Expansión Mínima</span> en el grafo de conexiones.</p>
				</section>
				<section>
					<p>Agregando complejidad al problema, el mismo nos pide los dos planes con menos costo. Veremos como resolver esto más adelante.</p>
				</section>
			</section>
			<section>
				<section>
					<h2>Arbol de Expansión Mínima</h2>
				</section>
				<section>
					<p>Para que se cumpla el criterio de conectividad se necesitan <span class="fragment highlight-red">V - 1 aristas que abarquen todos los vértices de \(G\)</span></p>
				</section>
				<section>
					<p>Para resolver esta cuestión deberiamos buscar algún algoritmo que plantee la menor cantidad de dificultades. Se necesitaria algun algoritmo voraz que me permita todo lo anteriormente mencionado.</p>
				</section>
			</section>
			<section>
				<section>
					<h3>Algoritmo de Kruskal</h3>
				</section>
				<section>
					<p>El algoritmo de kruskal es un algoritmo de la teoría de grafos que permite encontrar un árbol recubridor mínimo en un grafo conexo y ponderado. Es decir, busca un subconjunto de aristas que, formando un árbol, incluyen todos los vértices y donde
						el valor de la suma de todas las aristas del árbol es el mínimo. Si el grafo no es conexo, entonces busca un bosque expandido mínimo (un árbol expandido mínimo para cada componente conexa).</p>
				</section>
				<section>
					<p>Algoritmo de Kruskal</p>
					<ul>
						<li class="fragment fade-up">
							Ordena las \(E\) aristas en orden no decreciente según el peso.
						</li>
						<li class="fragment fade-up">
							Trata de agregar cada arista en el MST en orden, si no forma un ciclo.</p>
							<ul>
								<li class="fragment fade-up">Utiliza UFDS</li>
							</ul>
						</li>
					</ul>
				</section>
				<section>
					<h2>Pseudo-código</h2>
					<pre><code class="cpp hljs" data-trim contenteditable>
						function kruskal(G)
							for v in V[G] do
								new Set C(v) ← {v}.

							new heap Q containing all the edges of G, sorting by weight.
							define a tree MST ← Ø

							// n is the total number of vertices
							while MST has less than n-1 edges and  Q is not empty do
								(u,v) ← Q.pop()
								// prevents cycles in MST. Add (u, v) if u and v are different components in the set.
								// Notice that C(u) returns the component to which u belongs.
								if C(v) ≠ C(u) then
									push back (v,u) on MST.
									merge C(v) and C(u) in the set

							return MST
					</code></pre>
				</section>
				<section>
					<h3>Orden de ejecución</h3>
					<p>O(ordenar las aristas + tratar de agregar cada arista x costo de las operaciones de UFDS)</p>
				</section>
				<section>
					<p>\[ O(E \space log \space E \space + E \space (≈1)) \]</p>
					<p>\[ \Rightarrow O(E \space log \space E) \]</p>
					<p>\[ \Rightarrow O(E \space log \space V2 ) \]</p>
					<p>\[ \Rightarrow O(2 \space E \space log \space V) \]</p>
					<p>\[ \Rightarrow O(E \space log \space V) \]</p>
				</section>
			</section>
			<section>
				<section>
					<h2>Union Find Disjoint Set</h2>
				</section>
				<section>
					<p>Con el fin de manejar conjuntos disjuntos, creamos una estructura la cual permita realizar operaciones de búsqueda y unión de forma eficiente. Lo utilizamos en este problema para saber si un vértice está en la misma componente que otro.</p>
				</section>
				<section>
					<h3>Make Set</h3>
					<pre><code class="hljs" data-trim contenteditable>
						function MakeSet(x)
							if x is not already present:
								add x to the disjoint-set tree
								x.parent := x
								x.rank   := 0
					</code></pre>
					<p class="fragment fade-up">Orden de ejecución: \(O(1)\)</p>
				</section>
				<section>
					<h3>Find</h3>
					<pre><code class="hljs" data-trim contenteditable>
						function Find(x)
							if x.parent != x
								x.parent := Find(x.parent)
							return x.parent
					</code></pre>
				</section>
				<section>
					<h3>Union</h3>
					<pre><code class="hljs" data-trim contenteditable>
						function Union(x, y)
							xRoot := Find(x)
							yRoot := Find(y)

							// x and y are already in the same set
							if xRoot == yRoot
								return

							// x and y are not in same set, so we merge them
							if xRoot.rank < yRoot.rank
								xRoot.parent := yRoot
							else if xRoot.rank > yRoot.rank
								yRoot.parent := xRoot
							else
								//Arbitrarily make one root the new parent
								yRoot.parent := xRoot
								xRoot.rank   := xRoot.rank + 1
					</code></pre>
				</section>
			</section>
			<section>
				<section>
					<h2>Segundo mejor árbol de expansión</h2>
				</section>
				<section>
					<p>En caso en que no funcione el MST, podemos buscar el segundo mejor.</p>
					<ul>
						<li class="fragment fade-up">
							Ordenar las aristas <span class="fragment fade-left">\(\leftarrow O(E \space log \space V)\)</span>
						</li>
						<li class="fragment fade-up">
							Buscar el MST usando Kruskal <span class="fragment fade-left">\(\leftarrow O(E)\)</span>
						</li>
						<li class="fragment fade-up">
							Para cada arista (hay V -1 aristas), excluirla y volver a calcular el MST <span class="fragment fade-left">\(\leftarrow O(E)\)</span>
						</li>
					</ul>
				</section>
				<section>
					<h3>Orden de ejecución</h3>
					<p>\[O(E \times log(V) \space + \space E \space + V \times E) = O(V \times E)\]</p>
				</section>
			</section>
			<section>
				<section>
					<h2>Solución</h2>
				</section>
				<section>
					<p>La solución se dispone programada en el lenguaje C++. La misma se ve modularizada mediante la programación de dos estructuras, con sus respectivos métodos, y un programa principal.</p>
				</section>
				<section>
					<h3>Librerias y definición de Tipos</h3>
					<pre><code class="cpp hljs" data-trim contenteditable>
						#include &lt;iostream&gt;
						#include &lt;string&gt;
						#include &lt;vector&gt;
						#include &lt;utility&gt;
						#include &lt;algorithm&gt;

						#define INF 1 &lt;&lt; 30

						using namespace std;

						typedef pair&lt;int, int&gt; ii;
						typedef pair&lt;int, ii&gt; edge;

						bool operator < (const edge a, const edge b)
						{
							return a.first < b.first;
						}
					</code></pre>
				</section>
				<section>
					<h3>Disjoint Set</h3>
					<pre><code class="cpp hljs" data-trim contenteditable>
						struct DisjointSet
						{
							int sets, *parents, *rank;

							DisjointSet(int n)
							{
								int i;

								sets = n;
								parents = new int[n + 5];
								rank = new int[n + 5];
								for (i = 0; i < n; i++) {
									parents[i] = i;
									rank[i] = 0;
								}
							}

							int findSet(int x)
							{
								return (x == parents[x]) ? x : parents[x] = findSet(parents[x]);
							}

							bool isSameSet(int x, int y)
							{
								return findSet(x) == findSet(y);
							}

							void unionSet(int x, int y)
							{
								int xRoot = findSet(x), yRoot = findSet(y);

								if (isSameSet(xRoot, yRoot)) {
									return false;
								}

								if (rank[xRoot] < rank[yRoot]) {
									parents[xRoot] = yRoot;
								} else if (rank[xRoot] > rank[yRoot]) {
									parents[yRoot] = xRoot;
								} else {
									parents[yRoot] = xRoot;
									rank[xRoot]++;
								}

								sets--;

								return true;
							}
						}
					</code></pre>
				</section>
				<section>
					<h3>Graph</h3>
					<pre><code class="cpp hljs" data-trim contenteditable>
						struct Graph
						{
							int V, E;
							vector&lt;edge&gt; edges;

							Graph(int V, int E)
							{
								this->V = V;
								this->E = E;
							}

							void addEdge(int w, int a, int b)
							{
								edges.push_back(edge(w, ii(a, b)));
							}

							vector&lt;edge&gt; kruskal()
							{
								int i, w, from, to;
								vector&lt;edge&gt; MST;

								DisjointSet ds(V);
								sort(edges.begin(), edges.end());

								for(i = 0; i < edges.size(); i++) {
									w = edges[i].first;
									from = edges[i].second.first;
									to = edges[i].second.second;

									if (ds.unionSet(from, to)) {
										MST.push_back(edge(w, ii(from, to)));
									}
								}

								return MST;
							}

							int kruskal_2(int u, int v)
							{
								int i, total = 0;

								DisjointSet ds(V);

								for (i = 0; i < edges.size(); i++) {
									int from = edges[i].second.first;
									int to = edges[i].second.second;

									if (from == u &amp;&amp; to == v) {
										continue;
									}

									if (ds.unionSet(from, to)) {
										total += edges[i].first;
									}
								}

								if (ds.sets != 1) {
									return INF;
								}

								return total;
							}
						}
					</code></pre>
				</section>
				<section>
					<h3>Main</h3>
					<pre><code class="cpp hljs" data-trim contenteditable>
					int main()
					{
						int i, size, ans, TC, V, E, a, b, w, s1, s2;
						vector&lt;edge&gt; MST;

						cin >> TC;
						while(TC--)
						{
							cin >> V >> E;

							Graph graph(V, E);

							for (i = 0; i < E; i++) {
								cin >> a >> b >> w;
								graph.addEdge(w, --a, --b);
							}

							MST = graph.kruskal();
							s1 = 0, s2 = INF;
							size = MST.size();

							for (i = 0; i < size; i++) {
								s1 += MST[i].first;
							}

							for (i = 0; i < size; i++) {
								s2 = min(s2, graph.kruskal_2(MST[i].second.first, MST[i].second.second));
							}

							ans = s2 == INF ? s1 : s2;

							cout << s1 << " " << ans << endl;
						}

						return 0;
					}
					</code></pre>
				</section>
				<section>
					<h3>Solución en github</h3>
					<p><a target="_blank" href="https://github.com/ulises-jeremias/Solutions/blob/master/uva.onlinejudge.org/ACMContestandBlackout.cpp">ACM Contest and Blackout</a></p>
				</section>
			</section>
		</div>
	</div>

	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.js"></script>

	<script>
		// More info https://github.com/hakimel/reveal.js#configuration
		Reveal.initialize({
			history: true,
			transition: 'convex',
			math: {
				// mathjax: 'http://cdn.mathjax.org/mathjax/latest/MathJax.js',
				config: 'TeX-AMS_HTML-full'
			},
			// More info https://github.com/hakimel/reveal.js#dependencies
			dependencies: [{
					src: 'plugin/markdown/marked.js'
				},
				{
					src: 'plugin/markdown/markdown.js'
				},
				{
					src: 'plugin/notes/notes.js',
					async: true
				},
				{
					src: 'plugin/highlight/highlight.js',
					async: true,
					callback: function() {
						hljs.initHighlightingOnLoad();
					}
				},
				{
					src: 'lib/js/classList.js'
				},
				{
					src: 'plugin/math/math.js',
					async: true
				}
			]
		});
	</script>

</body>

</html>
